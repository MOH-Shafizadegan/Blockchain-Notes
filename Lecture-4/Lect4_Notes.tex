\documentclass{report}
\usepackage{graphicx}

\input{./includes/preamble}
\input{./includes/macros}
\input{./includes/letterfonts}

\title{\Huge{Principles of Blockchains \\ Princeton University,\\
		Professor: Pramod Viswanath}}
	
\author{\huge{Lecture 4} \\\\ Peer to Peer Network}

\begin{document}

\maketitle
\newpage% or \cleardoublepage
% \pdfbookmark[<level>]{<title>}{<dest>}
\pdfbookmark[section]{\contentsname}{toc}
\tableofcontents
\pagebreak

\chapter{Peer to Peer Network}
\section{Blockchains and Networking}
A blockchain network is a system that provides ledger and smart contract services to applications without relying on a centralized server or authority. A centralized server can be a single point of failure or a target for censorship, which can compromise the security and availability of the network. Therefore, a blockchain network has the following networking requirements:
\begin{itemize}
	\item 
	The key primitive of the network is to \textbf{broadcast blocks and transactions to all nodes}.\\ Blocks are data structures that contain transactions, which are records of value transfers or contract executions. Transactions are validated and appended to the ledger by consensus algorithms. Broadcasting ensures that all nodes have the same view of the ledger and can verify its integrity.
	\item 
	The network also needs to be \textbf{robust and resilient to node failures or attacks}. \\ Some nodes may go offline due to various reasons, such as power outages, network disruptions, or malicious attacks. The network should be able to tolerate a certain percentage of node failures without affecting its functionality. Moreover, the network should allow new nodes to join and synchronize with the existing nodes, as well as handle node churns and partitions.
\end{itemize}
\subsection{Types of Network Architecture}
There are two types of network architecture:
\begin{enumerate}
	\item \textbf{Client Server} : \\
	This is a type of network architecture where one or more servers store most of the data and resources, and the clients access them through requests. The server is the central authority that controls the network, and the clients are dependent on the server for their functionality.
	\item \textbf{Peer to Peer} :\\
	This is a type of network architecture where each node acts as both a client and a server, and there is no central authority or hierarchy. The nodes share their data and resources directly with each other, without relying on a server.
\end{enumerate}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.6\linewidth]{Fig/F1}
	\caption{Types of Network Architecture}
	\label{fig:f1}
\end{figure}
The need for robustness implies that we do not want a client-server relationship; we settle for a peer-to-peer (P2P) network where each node has identical behavior.
\subsection{Overlay Networks}
An overlay network depicts the connections between nodes, and is represented as a graph. It abstracts out the physical network switches and routers and defines virtual links between nodes. Two nodes that are connected by a link can exchange messages directly. Those that are not connected by a link must find a path connecting them on this overlay
network in order to communicate messages.
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth]{Fig/F2}
	\caption{Overlay Network}
	\label{fig:f2}
\end{figure}\\
There are different ways to classify overlay networks, but one common way is to distinguish between two types of overlay networks
\begin{itemize}
	\item \textbf{structured} : These are overlay networks that have a specific topology or organization, such as a ring, a tree, or a grid. Structured overlay networks, like CHORD, assign an identifier to each node and uses that to construct welldefined
	routing rules. These networks are excellent for routing sending point to point messages, a use case not required for Bitcoin. Structured networks are suitable for broadcast, too; any message transmission takes O(logN) hops on CHORD with O(logN) connections per node.
	\item \textbf{unstructured} : These are overlay networks that have no specific topology or organization, and the nodes are connected randomly or based on some criteria, such as proximity, interest, or availability. Unstructured networks like d-regular graphs have no node identifiers; a node connects to d other nodes randomly.
\end{itemize}
Routing point to point messages is not feasible because it takes O(logN) hops and requires many peer queries to find the path from point A to point B. However, broadcast is very effective using gossip and also takes O(logN) hops. Therefore, the number of hops needed is equal to the structured network with the extra advantage of O(1) peer connections. That is why the Bitcoin network uses an unstructured d-regular overlay network.
\subsection{Gossip and Flooding}
Gossip and Flooding are two techniques for disseminating information in a network of nodes. Gossip is a technique that randomly sends the information to some of its neighbors, while Flooding sends the information to all of its neighbors. Both techniques can spread the information exponentially and reach all nodes in O(logN) time.\\
Gossip and Flooding can be used to achieve fast and reliable information dissemination in a network, but they differ in terms of efficiency, overhead, and robustness.
\subsection{Expander Graph}
Expander graph is a type of graph that has the property of being well connected but sparse. 
\dfn{Sparse Graph}{A sparse graph $G(V,E)$ is a graph that has a small number of edges compared to the number of vertices, such that $|E| = O(|V|)$, where $|E|$ is the number of edges and $|V|$ is the number of vertices. \\\\
An Expander graph is a sparse graph that is also well connected, such that for any subset $A$ of vertices, the number of vertices outside $A$ that have at least one neighbor in $A$, denoted by $|A|$, is large.}
A gossip message starts with $A(0)$ as the broadcasting node with $|A(0)| = 1$. In the next hop, it will reach $\partial A(0)$ with $|A(1)|$ being at least $(1 + \epsilon)$ times $|A(0)|$. This process repeats and we get $|A(k)|$ being at least $(1 + \epsilon)^k$ times $|A(0)|$ for any $k$. Therefore, the number of steps to get to half the number of nodes is proportional to the logarithm of the number of nodes. It can be proven that the other half of the nodes can also be reached in O(logN) time.

\section{Bitcoin Network}
Bitcoin is a peer-to-peer network that uses TCP protocol to exchange data. In Bitcoin network:
\begin{itemize}
	\item The codebase limits the number of outgoing connections to eight and the number of incoming connections to 117.
	\item The network has a high churn rate (rate at which users join or leave the system); therefore, the node must be prepared to connect to new peers.
	\item The node maintains a large list of nodes running Bitcoin in the form of their (IP, port) pair and connects to one of them randomly when a slot becomes available.
	\item The node ensures that the peers it connects to are selected randomly.
\end{itemize}
\subsection{Peer discovery}
A node starts its list of peers by connecting to a group of DNS seed nodes. These are special nodes that provide a list of IP addresses and ports of active nodes in the network. A node can query a DNS seed node to get this list and then try to connect to some of the nodes in the list.\\
The seed nodes are not very distributed; so it is not wise to depend entirely on the peer list given by them. After connecting to the first set of peers, a node requests their peer list using \textbf{getAddr} and \textbf{Addr} messages. The node updates its peer list frequently by swapping peer lists with its peers.
\subsection{Block transmission}
The process of transmitting blocks and transactions involves the following steps:
\begin{enumerate}
	\item A node sends an \textbf{inv} message to its peers, which is an inventory message that tells them what blocks and transactions are available.
	\item When a peer receives an \textbf{inv} message, it checks if it already has the block or the transaction in its local storage. If not, it sends a \textbf{getData} message to the node to get those blocks and transactions.
	\item Optionally, the peer can request only the headers of the blocks first, using a \textbf{getHeaders} message, before asking for the full blocks .
	\item This header-first block transmission can reduce the bandwidth use and prevent invalid blocks from being accepted .
\end{enumerate}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.8\linewidth]{Fig/F3}
	\caption{Block transmission in blockchain network}
	\label{fig:f3}
\end{figure}
\subsection{Data Broadcast}
Now we explain how data, such as transactions, are broadcasted in a peer-to-peer network
\begin{itemize}
	\item Each node maintains a non-persistent memory to store unconfirmed transactions, which are transactions that have not been included in a block yet. This memory is called the mempool.
	\item When a node receives a new transaction, it sends an inv message to its peers, which contains the transaction id (txid). The inv message is a way of checking if the peer already has the transaction in its mempool.
	\item If not, the peer sends a getdata message to request the full transaction data from the node. The node then sends the transaction data (tx) to the peer.
	\item Some unconfirmed transactions might be removed from the mempool due to various reasons, such as low fees, expiration time, or double spending.
\end{itemize}
\subsection{Compact Blocks}
Here we discuss two methods of relaying blocks in a peer-to-peer network:
\begin{enumerate}
	\item \textbf{legacy relaying} : \\
	Legacy relaying is the traditional way of sending the full block data to each node.
	\item \textbf{compact block relaying} : \\
	Compact block relaying is a protocol that reduces the amount of bandwidth and latency required to transfer a block that confirms many transactions that the nodes already have in their mempools.
\end{enumerate}
There some differences between the two methods in terms of the messages exchanged between the nodes .Here are the advantages of compact block relaying over legacy relaying:
\begin{itemize}
	\item Compact block relaying uses shortened transaction identifiers (txids) instead of full transaction data, which reduces the size of the block data.
	\item Compact block relaying allows nodes to request only the transactions they are missing from their mempools, which reduces the redundancy of sending transactions twice.
	\item Compact block relaying has two modes: low bandwidth mode and high bandwidth mode.\\ Low bandwidth mode minimizes the bandwidth usage by asking for permission before sending a compact block.\\ High bandwidth mode reduces the latency by sending a compact block as soon as possible without asking for permission.
	\item Compact block relaying can verify the proof of work (PoW) from the block header before requesting the full block data, which prevents invalid blocks from being accepted.
\end{itemize}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.6\linewidth]{Fig/F4}
	\caption{Compact Block}
	\label{fig:f4}
\end{figure}
There is a trade-off between capacity and propagation delay in a peer-to-peer network. \textbf{Capacity} (C) is the maximum amount of data that can be transmitted in a given time, measured in bits per second (bps). \textbf{Propagation delay} (D) is the time it takes for a signal to travel from one node to another, measured in seconds. The end to end delay, which is the total time it takes for a block to reach all nodes in the network, increases with the increase in block size. This is because larger blocks take longer to transmit and verify, which can cause congestion and orphaning. Therefore, there is a trade-off between increasing the capacity and reducing the propagation delay of the network. This increase in delay affect the system in following ways:
\begin{itemize}
	\item Wasted Hash power
	\item Forking
\end{itemize}
\subsection{Disadvantages of current p2p network}
\begin{itemize}
	\item \textbf{Efficiency:} \\ It requires a lot of communication between nodes. The total communication is proportional to the number of nodes (N) and the average degree of connectivity (d). This means that as the network grows, the communication overhead also increases, which can affect the performance and scalability of the system.
	\item \textbf{Privacy:} \\ It can link the transaction source to the IP address of the node that broadcasts it. This means that anyone who monitors the network traffic can potentially identify the sender and receiver of a transaction, which can compromise their anonymity and privacy.
	\item \textbf{Security:} \\ It allows for plausible deniability for forking. Forking can cause inconsistency and double spending. Plausible deniability means that a node can claim that it did not receive a valid block from another node, even if it did, and create a fork on purpose. This can be used as an attack strategy to disrupt the consensus and integrity of the system.
\end{itemize}

\section{Geometric Random Network}
The current network topology is based on random IP addresses, which are not related to geographic distances. This means that nodes may be connected to peers that are far away from them, which can increase the latency and bandwidth usage of the network. \\\\
A better network topology would be based on a \textbf{geometric random network}, which is a network where nodes are placed according to some geometric criteria, such as proximity or similarity. This way, nodes can connect to peers that are closer or more relevant to them, which can improve the efficiency and performance of the network. The challenges are creating a self-adapting network topology based on measurements, such as latency, bandwidth, or trust. This means that nodes can dynamically adjust their connections based on the changing conditions and preferences of the network.

\subsection{Perigee}
Perigee is a self-adaptive network topology algorithm for peer-to-peer networks. Perigee is a decentralized algorithm that selects neighbors based on past interactions. It aims to retain neighbors that relay blocks fast and disconnect from neighbors that do not relay blocks fast. It also explores unseen neighbors to discover new potential connections.\\\\
`Perigee is motivated by the multi-armed bandit problem, which is a problem of finding the optimal strategy for choosing among several options with uncertain rewards. Perigee tries to balance between exploration and exploitation, which means finding new neighbors and using existing neighbors, respectively. Perigee can improve the efficiency and performance of the peer-to-peer network by reducing the latency and bandwidth usage.

\subsubsection{Algorithm}
The Perigee Algorithm works as follows:
\begin{itemize}
	\item It assigns scores for each subset of neighbors based on how fast they relay blocks.
	\item It retains the subset of neighbors with the best score and disconnects the node that is not in the subset.
	\item It forms a connection to a random neighbor to explore new potential connections.
\end{itemize}
\begin{figure}[h!]
	\centering
	\includegraphics[width=\linewidth]{Fig/F5}
	\caption{Performance of Perigee}
	\label{fig:f5}
\end{figure}
\section{Efficient Networking}
 Efficient networking is the ability to transmit and receive data in a fast, reliable, and scalable way. There are three aspects of efficient networking:
 \begin{enumerate}
 	\item \textbf{Trusted networks} : \\
 	Trusted networks are networks where nodes can trust each other to relay valid and timely data. Trusted networks can improve the efficiency of the network by reducing the overhead and redundancy of data transmission. However, trusted networks also pose some risks, such as centralization and censorship.
 	\item \textbf{Privacy} : \\
 	Privacy is the ability to protect the identity and activity of nodes from external observers. Privacy can improve the efficiency of the network by reducing the exposure and vulnerability of nodes. However, privacy also poses some challenges, such as linking transaction source to IP address and plausible deniability for forking.
 	\item \textbf{Security} : \\
 	Security is the ability to prevent and resist attacks from malicious nodes or adversaries. Security can improve the efficiency of the network by maintaining the integrity and consistency of the data. However, security also poses some difficulties, such as eclipse attacks and plausible deniability for forking.
 \end{enumerate}
\subsection{FRN (Fast relay network)}
 FRN (Fast relay network) is an example of a trusted network model, which is a hub and spoke model where miners connect to FRN servers. FRN servers are trusted servers that are fast and efficient in relaying blocks and transactions. FRN servers can reduce the latency and bandwidth usage of the network by filtering and compressing the data. However, FRN servers also pose some risks, such as centralization, censorship, and single point of failure.
 \begin{figure}[h!]
 	\centering
 	\includegraphics[width=0.7\linewidth]{Fig/F6}
 	\caption{FRN}
 	\label{fig:f6}
 \end{figure}
 \subsection{Trusted Networks: Falcon}
 Falcon network routing is based on the idea of cut through routing, which is a method of forwarding data packets as soon as their headers are verified, without waiting for the whole packet to arrive. This can reduce the latency and bandwidth usage of the network, as well as the risk of forking and double spending. Falcon network routing uses a set of trusted servers, called FRN servers, to relay data packets between nodes.\\\\
\textbf{Cut through routing} is the way of sending data packets from point a to point b, where each node verifies the header of the packet and forwards it to the next node without waiting for the whole packet to arrive. The diagram shows that cut through routing has lower latency than legacy routing, which is represented by the distance between the green lines and the red lines in the diagram. The diagram also shows that cut through routing uses FRN servers to relay data packets between nodes.
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth]{Fig/F7}
	\caption{Legacy routing vs. Cut through routing}
	\label{fig:f7}
\end{figure}
\section{Network Anonymity and Privacy}
Blockchains are systems where the data structure of the blockchain is shared and visible to all participants. For example, in a cryptocurrency, the blockchain records every transaction that ever happened in the currency. However, this also means that the blockchain can contain sensitive data of users, such as their identities and balances. This can raise privacy concerns for users who do not want their data to be public. Therefore, privacy is an important issue in blockchains. How can users achieve privacy in blockchains?\\\\
Bitcoin and most other cryptocurrencies use pseudonymous identifiers to protect the privacy of users. Each user has one or more pseudonym, which is a public key that they use to participate in the system. The blockchain only shows the transaction patterns of each pseudonym, not the real identity of the user. However, this system is not very secure, because there are ways to link the pseudonyms to the user’s real identity, especially if there is extra information available. These are called de-anonymization attacks, and they can expose the user’s sensitive data.

\subsection{Network De-anonymization Problem}
he network de-anonymization problem is the challenge of finding the real identities of users who participate in a network that uses anonymization techniques. Anonymization techniques are methods that hide the personal information of users, such as their names and locations, by using random or fake identifiers. Anonymization techniques are supposed to protect the privacy of users, but they can be broken by attackers who have access to some extra information or techniques. The network de-anonymization problem can be modeled using a graph, where nodes represent users and edges represent connections between them. The attacker’s goal is to guess which node in the anonymized graph corresponds to which user in the original graph. The attacker can use different methods, such as eavesdropper adversaries or botnet adversaries, to collect and analyze data from the network. Eavesdropper adversaries are attackers who listen to all or most of the network traffic and use metadata and topology information to infer the source of a message. Botnet adversaries are attackers who control a set of compromised nodes that participate in the network normally and share information with each other. The network de-anonymization problem is a difficult and important problem for network security and privacy.\\\\
There are two main types of attackers in network de-anonymization:
\begin{enumerate}
	\item \textbf{Eavesdropper attackers} :\\ Eavesdropper attackers are attackers who connect to all or most of the nodes in the network and listen to their communications. They look like normal nodes to the honest nodes, who relay messages to them as usual. Eavesdropper attackers can collect metadata, such as timestamps and IP addresses, from the messages they receive. They can also use information about the network topology, such as the connections between nodes, to guess the source of a message. Eavesdropper attackers usually do not send any messages; they only observe and analyze the messages they receive.
	\item \textbf{Botnet attackers} : \\
	Botnet attackers are attackers who control a set of compromised nodes that act like normal nodes in the network. They can accept and relay messages from other nodes, but they also share information with each other. Botnet attackers can have limited visibility into the network, depending on how many nodes they control and how they are connected. Botnet attackers can also inject fake or modified messages into the network to confuse or mislead other nodes.
\end{enumerate}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth]{Fig/F8}
	\caption{Eavesdropper adversary (Left graph) - Botnet adversary (Right graph)}
	\label{fig:f8}
\end{figure}
De-anonymization algorithms are methods that can break the privacy of users who participate in a network that uses anonymization techniques. Anonymization techniques are ways of hiding the personal information of users, such as their names and locations, by using random or fake identifiers. However, these techniques can be defeated by attackers who have access to some extra information or techniques. De-anonymization algorithms are based on the idea of centrality or symmetry, which means that the source of a message is usually located at the center of a disc-shaped region on the network graph. The attackers can use metadata and topology information to infer the shape of the disc and identify the central node with a high probability. These algorithms show that diffusion, which is a common way of spreading messages on the network, is not very good at protecting the anonymity of users at the network level. Therefore, there is a need for alternative spreading protocols that can protect the anonymity of users.

\subsection{Flooding Protocol}
 Flooding protocols are methods of sending packets to all nodes in a network by having each node rebroadcast the packets it receives.Flooding protocols can be useful for applications such as firmware updates, routing information, and multicast forwarding. However, flooding protocols can also cause problems such as network congestion, packet loss, and high energy consumption.\\\\
 There are two flooding protocols:
 \begin{enumerate}
 	\item \textbf{Trickle} : \\
 	Trickle uses a \textbf{polite gossip} policy to control the send rates of nodes. Trickle divides time into intervals and each node maintains a counter of how many consistent packets it has heard from its neighbors. If the counter is below a threshold, the node transmits its packet with a high probability. Otherwise, the node transmits its packet with a low probability. This way, Trickle ensures that nodes hear enough packets to stay consistent, but not too many to cause redundancy.
 	\item \textbf{Diffusion} : \\
 	Diffusion uses an exponential backoff mechanism to reduce the send rates of nodes. Diffusion assigns each node an exponent value based on its hop distance from the source node. The exponent value determines how long the node waits before transmitting its packet. The closer the node is to the source, the smaller the exponent value and the shorter the waiting time. The farther the node is from the source, the larger the exponent value and the longer the waiting time. This way, Diffusion reduces the number of collisions and retransmissions in the network, and improves the reliability and efficiency of packet delivery.
 \end{enumerate}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.6\linewidth]{Fig/F10}
	\caption{Flooding Protocols}
	\label{fig:f10}
\end{figure}
Figure \ref{fig:f11} shows that Trickle has a higher probability of detection than Diffusion for any given number of eavesdropper connections. This means that Trickle is more effective in identifying and reporting eavesdropper connections than Diffusion.
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.7\linewidth]{Fig/F11}
	\caption{Performance of Trickle and Diffusion}
	\label{fig:f11}
\end{figure}\\
Diffusion does not have (significantly) better anonymity properties than trickle.
 
 \subsection{Anonymity in Botnet adversarial model}
 Anonymity is the degree to which a user’s identity and transactions are hidden from other users and observers. Anonymity can be measured by two factors: recall and precision. Recall is the probability that a user’s transactions are detected by an observer, while precision is the accuracy of the observer’s detection.
 \begin{figure}[h!]
 	\centering
 	\includegraphics[width=0.25\linewidth]{Fig/F12}
 	\caption{Mapping $M$}
 	\label{fig:f12}
 \end{figure}
 Recall can be calculated using the following formula
 \begin{align*}
 	\frac{1}{n}\sum_v 1\{M(v' \, s \, \text{tx}) = v\}
 \end{align*}
 where $n$ is the number of honest users in the network, $v$ is a user index, $M(v' \, s \, \text{tx})$ is the mapping function that assigns a user’s transactions to a user index, and $1\{M(v' \, s \, \text{tx}) = v\}$ is an indicator function that returns 1 if the mapping is correct and 0 otherwise.\\\\
 The formula for calculating precision is :
 \begin{align*}
 	\frac{1}{n}\sum_v \frac{1\{M(v' \, s \, \text{tx}) = v\}}{\text{\# tx mapped to } v}
 \end{align*}
Our goal is to design a distributed flooding protocol that minimizes the maximum precision and recall achievable by a computationally-unbounded adversary. \\
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.5\linewidth]{Fig/F13}
	\includegraphics[width=0.4\linewidth]{Fig/F14}
	\caption{Fundamental Limits}
	\label{fig:f13}
\end{figure}\\
Figure \ref{fig:f13} implies that we can’t have high precision-low recall and vice versa.

\subsection{Dandelion}
One of the main insights from studying how information spreads is that we need to make the communication protocol asymmetric, so that the adversary cannot easily figure out the message. This is the idea behind the Dandelion P2P network protocol, which has two stages:
\begin{enumerate}
	\item a \textbf{stem stage (or anonymity stage)} : \\
	In the stem stage, each node sends each message along a random direction. This stage lasts for a random number of hops
	\item a \textbf{fluff stage (or diffusion stage)} : \\
	in the fluff stage, the message is diffused to the whole network by broadcasting it
\end{enumerate} 
The stem stage provides anonymity, while the fluff stage ensures fast and reliable delivery.
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.6\linewidth]{Fig/F9}
	\caption{Spreading Protocol: Dandelion}
	\label{fig:f9}
\end{figure}
We will describe the Dandelion protocol in more detail next. Dandelion works in epochs that are not synchronized; each node changes its epoch when its internal clock reaches a random value (in practice, this will be a few minutes). Within an epoch, the main algorithmic components of Dandelion are:
\begin{enumerate}
	\item \textbf{Anonymity graph:}\\ The random walk happens on a layer of the P2P graph called the anonymity graph. This layer should be either a random cycle graph (i.e., a graph with two edges per node) or a graph with four edges per node. This graph with four edges per node is created from the P2P graph by having each node pick (up to) two of its outgoing edges, without repeating, randomly as Dandelion relays. This does not make an exact graph with four edges per node, but a close one. Each time a node moves to the next epoch, it chooses new Dandelion relays.
	\item \textbf{Sending of a node’s own transactions:}\\ Each time a node creates a transaction, it sends the transaction in stem phase along the same random edge on the anonymity graph. If the anonymity graph is a cycle, there is only one edge per node; otherwise, the node must pick one of its two edges.
	\item \textbf{Relaying of other nodes’ transactions} : \\  Each time a node gets a transaction in stem phase from another node, it either passes the transaction on or broadcasts it. The decision to broadcast transactions is pseudo-random, and is based on a hash of the node’s own identity and epoch number. Note that the choice to broadcast does not depend on the transaction itself—in each epoch, a node is either a broadcaster or a passer for all passed transactions. If the node is not a broadcaster in this epoch (i.e.,it is a passer), then it passes transactions pseudo-randomly; each node assigns each of its incoming edges in the anonymity graph to an outgoing edge in the anonymity graph (with repetition). This assignment is chosen at the start of each epoch, and determines how transactions are passed.
	\item \textbf{Robustness mechanism}:\\ Each node keeps track, for each transaction in stem phase that it sends or passes on, whether the transaction comes back as a transaction in fluff phase within some random time. If not, the node begins to broadcast the transaction.
\end{enumerate}
Dandelion spreading can achieve the lowest possible recall for any given fraction of spies in the network. 
\thm{Recall of Dandelion}{Dandelion spreading has an optimally low maximum recall of \begin{align*}
		p + O \left(\frac{1}{n}\right)
	\end{align*}.}
The theorem implies that no algorithm can reduce the accuracy of detection by an adversary below this bound.
\thm{Precision of Dandelion}{Dandelion has a nearly-optimal 
	maximum precision of \begin{align*}
		\frac{2p^2}{1-p} \, \log\left(\frac{2}{p}\right) + O \left(\frac{1}{n}\right) \quad \text{ for } p < \frac{1}{3}
	\end{align*}
}
Figure \ref{fig:f15} is a timeline chart that shows the evolution of privacy technologies in cryptocurrencies.
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.75\linewidth]{Fig/F15}
	\caption{Evolution timeline}
	\label{fig:f15}
\end{figure}


\section{Basic requirements for a banking system}

In any currency/banking system, there are some basic requirements that the system must provide for. We list them here:
\begin{enumerate}
	\item There should be a unit of currency/money.
	\item There should be a standard way of keeping accounts, i.e., keeping track of how much money each person owns, and transferring money between accounts.
	\item No user should be able to create new money from thin air. Put diﬀerently, there should be a
	fixed amount of money in the system at any given time, and new money should be introduced in a systematic manner.
	\item A user should not be able to spend more money than he/she owns. There should be a way to verify whether or not this happens.
	\item One user should not be able to spend someone else’s money (at least, not without their permission).
	 
\end{enumerate}
Let us see how the Bitcoin system provides these features.

\section{Bitcoin and Satoshi}
\begin{enumerate}
	\item The basic unit of currency in the Bitcoin system is Bitcoin, and the smallest denomination is called a Satoshi, which is equal to $10^{-8}$ Bitcoins.
	\item All transactions in Bitcoin must be an integer multiple of a Satoshi.
	\item Just like other currencies, there is an exchange rate between Bitcoin and the dollar. As of July 22, 2023, one Bitcoin is worth 30,000 US dollars. However, the exchange rate between Bitcoin and dollars is very volatile due to various factors, including greed and speculation.
	\item The classification of Bitcoin as a currency (like the US Dollar) or a store of value (like gold) has been widely debated. The mainstream view is that Bitcoin is a combination of both.
	\item Economically valuing Bitcoin, both in the short and long terms, is an active area of research.
	\item Understanding the economic aspects of Bitcoin, both as a currency and a store of value, involves studying various aspects of the Bitcoin system.
\end{enumerate}

\section{Transactions}
In ordinary parlance, the term \textbf{transaction} refers to an exchange of something of value. In the context of Bitcoin and cryptocurrencies, a transaction is simply a message that specifes the transfer of money from one entity to another. In fact, transactions are the data-values that get recorded on the blockchain. The blockchain as a ledger is therefore an ordered list of transactions. From this publicly verifable ledger, any user can detect whether transactions are made according to certain rules or not, thereby lending credibility to the ledger and the currency.
\subsection{Addressing}
\begin{enumerate}
	\item \textbf{Bitcoin Address and Its Generation:}
	\begin{itemize}
		\item In Bitcoin, the notion of traditional accounts is replaced with addresses.
		\item An address is simply the hash of a user's public key. It is a unique alphanumeric string that serves as a destination for receiving bitcoins.
		\item Addresses are also used to determine where bitcoins will be sent in a transaction.
		\item New pairs of public and private keys, and thus new addresses, can be generated at will by a single user.
	\end{itemize}
	\item \textbf{Receiving vs. Spending Coins:}
	\begin{itemize}
	\item To receive coins, a user only needs to share their Bitcoin address with others. The address serves as a public identifier for receiving funds.
	\item However, to spend coins, a user must also reveal the corresponding public key associated with the address.
	\item This is because spending requires providing proof of ownership through a digital signature, which is created using the user's private key.
	\item The idiosyncrasy lies in the fact that while an address (hash of public key) is publicly visible and used for receiving, the associated public key is only revealed during the spending process for cryptographic verification.
	\end{itemize}
\end{enumerate}
\subsection{Transaction inputs and outputs}
\begin{enumerate}
	\item \textbf{Transaction Inputs:} 
	\begin{itemize}
		\item Each transaction input represents the amount of Bitcoin being spent from a specific address.
		\item When a user initiates a transaction, they reference one or more previous unspent transaction outputs (UTXOs) from the blockchain that they have the right to spend.
		\item These UTXOs serve as the inputs to the new transaction and determine the source of the funds being spent.
		\item Each input includes a reference to the UTXO's transaction ID and its output index, along with a cryptographic signature to prove ownership.
	\end{itemize}
	\item \textbf{Transaction Outputs:}
	\begin{itemize}
		\item Each transaction output represents the amount of Bitcoin being received by a specific address.
		\item When a transaction is created, it typically includes multiple outputs, each specifying the amount of Bitcoin and the recipient's address.
		\item These outputs determine the destinations of the funds being transferred in the transaction.
		\item Each output locks the specified amount of Bitcoin to the recipient's address using a locking script that can only be unlocked with the corresponding private key.
	\end{itemize}
	\item \textbf{Balance Consistency:}
	\begin{itemize}
		\item In every valid transaction, the total amount of Bitcoin being spent (sum of inputs) must equal the total amount being received (sum of outputs).
		\item This ensures that the transaction preserves the overall balance of the Bitcoin system, i.e., no new bitcoins are created, and no bitcoins are lost during the transaction process.
	\end{itemize}
\end{enumerate}
\subsection{Signatures on transactions}
\begin{enumerate}
	\item \textbf{Signing Transactions for Safety:} 
	\begin{itemize}
		\item Each transaction in Bitcoin must be signed by the users who are spending money. This process is a fundamental safety feature that prevents unauthorized access to someone's funds.
		\item For every transaction input, the user creating the transaction must sign it using the corresponding private key associated with the address from which the funds are being spent.
		\item By signing the transaction, the user proves ownership of the private key and authorizes the transfer of funds.
	\end{itemize}
	\item \textbf{One-to-One Correspondence: Public and Private Keys:}
	\begin{itemize}
		\item As mentioned earlier, each address in Bitcoin has a one-to-one correspondence with a public key, and each public key has a corresponding private key.
		\item When a user wishes to spend Bitcoins associated with a particular address, they create the transaction and then sign it using the private key linked to that address.
	\end{itemize}
	\item \textbf{Verification of Signatures:}
	\begin{itemize}
		\item After a user signs a transaction, they broadcast it to the network along with the corresponding public key (not the private key).
		\item Anyone who sees the signed transaction can verify its authenticity by checking whether it was signed with the private key associated with the public key provided.
		\item By doing so, other users can validate that the transaction was indeed signed by the rightful owner of the address (and the coins in that address).
	\end{itemize}
	\item \textbf{Multiple Addresses, Multiple Signatures:}
	\begin{itemize}
		\item In transactions that spend Bitcoins from multiple addresses, there must be signatures corresponding to each of these addresses.
		\item Each input requires a valid signature to prove ownership and authorization for spending the funds associated with that particular address.
	\end{itemize}
\end{enumerate}
\subsection{UTXO}
The UTXO (Unspent Transaction Output) model is a key feature of the Bitcoin system that ensures the security and validity of transactions. Let's summarize the important points about the UTXO model and how it facilitates transactions with multiple inputs and outputs:
\begin{enumerate}
	\item \textbf{UTXO Model for Validating Transactions:} 
	\begin{itemize}
		\item In the UTXO model, every transaction input must be a transaction output of a previous transaction, linking the spending of funds to their source.
		\item When a new transaction output is created, it is considered unspent until it gets consumed as an input in a future transaction when the funds are spent.
		\item A valid transaction can only include unspent transaction outputs (UTXOs) as its inputs, providing proof that the address indeed has sufficient funds to spend.
	\end{itemize}
	\item \textbf{Preventing Double-Spending:}
	\begin{itemize}
		\item By keeping track of UTXOs at all times, honest users can validate every new transaction against this set to prevent double-spending attempts by dishonest users.
		\item To spend their money, users must provide a valid chain of ownership through the UTXO history, ensuring that each input is a previously unspent output.
	\end{itemize}
	\item \textbf{Multiple Transaction Outputs (Outputs and Change):}
	\begin{itemize}
		\item A transaction may have multiple outputs, allowing users to send funds to multiple recipients in a single transaction.
		\item For example, if a user owns an address with 2 Bitcoins in an unspent output and wants to spend 1 Bitcoin, the transaction will have two outputs: one for the recipient and one for themselves (the change).
		\item The change output sends the remaining 1 Bitcoin back to the user's address or a new address.
	\end{itemize}
	\item \textbf{Multiple Transaction Inputs:}
	\begin{itemize}
		\item Users can include multiple transaction inputs in a single transaction to combine funds from different unspent outputs for larger transactions.
		\item For instance, if a user owns an address with 1 Bitcoin from two separate unspent outputs and wants to pay 2 Bitcoins to another address, they can include both unspent outputs as inputs in the transaction.
	\end{itemize}
\end{enumerate}
The UTXO model's design ensures that each transaction is valid, and its structure allows for flexibility in handling various scenarios, such as spending from multiple sources and sending funds to multiple recipients in one transaction. The adoption of the UTXO model is one of the key factors that contribute to the security and integrity of the Bitcoin blockchain.
\subsection{Cryptocurrency wallets}
	Cryptocurrency wallets play a crucial role in simplifying the process of managing and transacting with cryptocurrencies like Bitcoin. Here are the key points about cryptocurrency wallets:\\
\begin{enumerate}
	\item \textbf{Complexity of UTXO Management:} 
	\begin{itemize}
		\item Keeping track of UTXOs and measuring them for each transaction can be complex and challenging for regular users.
		\item Additionally, to maintain anonymity, users often generate new addresses regularly, which requires careful handling of private keys and secure storage.
	\end{itemize}
	\item \textbf{The Role of Cryptocurrency Wallets:} 
	\begin{itemize}
		\item Cryptocurrency wallets are software applications that handle many of the complex tasks in the background, making it easier for users to transact in cryptocurrencies.
		\item Wallets manage UTXOs, track balances, create new addresses, and handle cryptographic signatures for transaction verification.
	\end{itemize}
	\item \textbf{Anonymity and Security:}
	\begin{itemize}
		\item Wallets ensure that new addresses (and the corresponding keys) are generated securely without revealing private keys.
		\item For maintaining anonymity, wallets often offer features like generating new addresses for each transaction, making it harder to link transactions to a specific user.
	\end{itemize}
	\item \textbf{Secure Storage and Usage:}
	\begin{itemize}
		\item Wallets provide a secure storage solution for private keys, protecting them from unauthorized access or theft.
		\item Users must be cautious and responsible for securing their wallet's private keys since compromising them could result in the loss of funds.
	\end{itemize}
	\item \textbf{Trust in Wallet Software:}
	\begin{itemize}
		\item Using a cryptocurrency wallet requires placing trust in the software's functionality and security.
		\item Using a cryptocurrency wallet requires placing trust in the software's functionality and security.
	\end{itemize}
\end{enumerate}
\subsection{Transaction fees}
	Transaction fees play a crucial role in the Bitcoin network and serve as an incentive for miners to include transactions in the blocks they mine. Here are the key points about transaction fees:
\begin{enumerate}
	\item \textbf{Total Value in Inputs and Outputs:} 
	\begin{itemize}
		\item In a Bitcoin transaction, the total value in the inputs (UTXOs being spent) must be equal to or greater than the total value in the outputs (newly created UTXOs).
		\item The difference between the total value in inputs and outputs is known as the transaction fees.
	\end{itemize}
	\item \textbf{Transaction Fees as Miner Incentives:}
	\begin{itemize}
		\item The transaction fees are claimed by the miner who successfully includes the transaction in a block and adds that block to the blockchain.
		\item Miners compete to add transactions to their blocks because the fees they collect are an additional reward on top of the block reward (newly minted Bitcoins).
	\end{itemize}
	\item \textbf{Transaction Prioritization and Speed:}
	\begin{itemize}
		\item Transactions with higher fees are more attractive to miners because they earn more rewards for including them in their blocks.
		\item Miners prioritize transactions with higher fees, leading to faster inclusion of these transactions in the blockchain.
		\item Transactions with lower fees may take longer to be confirmed since they are lower in the priority list.
	\end{itemize}
	\item \textbf{Automatic Fee Calculation:}
	\begin{itemize}
		\item Wallets automatically calculate transaction fees based on a particular fee rate, measured in Satoshi per kilobyte (Satoshi/kB).
		\item The fee rate determines the amount of Satoshi to be paid per kilobyte of transaction data.
		\item Higher fee rates result in faster confirmation times, while lower rates may lead to delayed confirmations.
	\end{itemize}
	\item \textbf{Dynamic Fee Variation:}
		\begin{itemize}
		\item Transaction fees can vary over time due to fluctuations in network demand and block space availability.
		\item During periods of high network congestion, transaction fees may increase as users compete for limited block space.
	\end{itemize}
\end{enumerate}

\subsection{Coinbase transactions}
Coinbase transactions are a crucial mechanism for introducing new Bitcoins into the Bitcoin system and rewarding miners for their efforts in processing transactions and adding blocks to the blockchain. Here are the key points about coinbase transactions:
\begin{enumerate}
	\item \textbf{Introduction of New Bitcoins:}
	\begin{itemize}
		\item New Bitcoins are introduced into the system as a reward for miners who successfully mine a new block.
		\item Every block includes a special transaction known as the "coinbase transaction," which allows the miner to claim a fixed number of newly created Bitcoins.
	\end{itemize}
	\item \textbf{Block Reward Halving:}
	\begin{itemize}
		\item Initially, when Bitcoin was launched, the block reward for miners was 50 BTC per block.
		\item Approximately every 210,000 blocks (about four years), the block reward is halved through an event known as "halving."
		\item This means that after each halving, miners receive half the number of Bitcoins as the previous reward.
	\end{itemize}
	\item \textbf{Current Block Reward:}
	\begin{itemize}
		\item As of now, there have been three halvings, and the current block reward for miners is 6.25 BTC per block.
		\item The block rewards will continue until the year 2140 when the total supply of Bitcoin will reach its cap.
	\end{itemize}
	\item \textbf{Fixed Supply of Bitcoin:}
	\begin{itemize}
		\item The total supply of Bitcoin is capped at 21 million coins.
		\item This fixed supply ensures that there will never be more than 21 million Bitcoins in circulation.
		\item Approximately 19.4 million coins are already in circulation, and the remaining Bitcoins will be gradually introduced through coinbase transactions until the cap is reached.
	\end{itemize}
	\item \textbf{Incentive Mechanism:}
	\begin{itemize}
		\item Coinbase transactions, along with transaction fees, serve as incentives for miners to actively participate in the network and secure the blockchain through the proof-of-work process.
		\item In the early years of Bitcoin, coinbase transactions formed a significant portion of the rewards for miners, but over time, the contribution of transaction fees has increased.
	\end{itemize}
\end{enumerate}
The combination of coinbase transactions and transaction fees ensures the proper functioning and security of the Bitcoin network. Miners are motivated to continue mining, securing the network, and processing transactions as they receive both block rewards and transaction fees as incentives for their efforts. The gradual reduction in block rewards through halvings also creates a deflationary monetary policy, which further contributes to Bitcoin's scarcity and potential value appreciation over time.

\subsection{Transaction mempool}
The transaction mempool plays a crucial role in the process of how Bitcoin transactions are propagated, verified, and eventually included in blocks. Here are the key points about the transaction mempool and its significance:
\begin{enumerate}
	\item \textbf{Transaction Propagation:}
	\begin{itemize}
		\item When a user wants to make a Bitcoin transaction, they create a transaction message, sign it using their private key, and broadcast it across the Bitcoin network.
		\item The transaction message is a few kilobytes in size and contains information about the transaction inputs, outputs, and the corresponding digital signatures.
		\item Miners in the network receive these transactions and verify the signatures before adding them to their memory pool, known as the "mempool."
	\end{itemize}
	\item \textbf{The Mempool:}
	\begin{itemize}
		\item The mempool is a temporary storage area where miners keep pending transactions that they have received and verified.
		\item Transactions in the mempool are waiting to be included in a block and added to the blockchain.
		\item Miners prioritize which transactions to include in their working block based on factors like the transaction fee rate (higher fee with smaller size).
	\end{itemize}
	\item \textbf{Block Size Limit:}
	\begin{itemize}
		\item Each block in the Bitcoin blockchain has a maximum size limit, currently set at 1 megabyte (MB) in the Bitcoin network.
		\item Miners aim to maximize the total transaction rewards in their block while adhering to this size limit.
	\end{itemize}
	\item \textbf{Transaction Fee Rates:}
	\begin{itemize}
		\item Miners prioritize transactions with higher transaction fees because they want to maximize their potential reward for including transactions in a block.
		\item Transactions with higher fees are more likely to be included in blocks sooner, incentivizing users to offer higher fees if they want their transactions processed quickly.
	\end{itemize}
	\item \textbf{Confirmation Latency:}
	\begin{itemize}
		\item There is a certain latency between the time a transaction is issued and when it is confirmed on the blockchain. This latency is influenced by two factors: (a) the time it takes for a transaction to be included in a block (can be reduced by offering a higher transaction fee), and (b) the time it takes for that block to be buried deep enough in the longest chain for the transaction to be considered confirmed.
		\item Users may choose to trade off latency for security, deciding whether to use higher transaction fees for faster confirmation or lower fees for potentially longer confirmation times.
	\end{itemize}
	\item \textbf{Blockchain Design Trade-offs:}
	\begin{itemize}
		\item The trade-off between latency and security is specific to the Bitcoin blockchain design.
		\item Other blockchain designs may have different approaches and trade-offs, which will be explored in future lectures.
	\end{itemize}
\end{enumerate}
The mempool and the prioritization of transactions based on fees are essential components that allow the Bitcoin network to efficiently process and confirm transactions while incentivizing miners to maintain the security of the blockchain through the proof-of-work process.

\end{document}